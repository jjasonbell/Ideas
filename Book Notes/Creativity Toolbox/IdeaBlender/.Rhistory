library(Matrix)#
#
#################################################################################
#  Initializations.  Model where sellers can multihome, beta * b = l,#
# competition, and zero fixed costs for sellers.  #
#################################################################################
#
reps <- 5#
lbar <- 1#
num <- 100#
c1 <- seq(0, lbar, length.out = num)#
l <- length(c1)#
c2 <- 0#
n <- 1000#
p0 <- c(0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1)#
iters <- 100#
tols <- 0.001#
fp <- array(0, dim = c(l, 7, reps))#
fd <- array(0, dim = c(l, 2, reps))#
fprf <- array(0, dim = c(l, 4, reps))#
fprf2 <- array(0, dim = c(l, 5, reps))#
fw <- array(0, dim = c(l, 4, reps))#
p1A <- rep(0, l); p2A <- rep(0, l); psA <- rep(0, l)#
p1G <- rep(0, l); p2G <- rep(0, l); psG <- rep(0, l)#
dba <- rep(0, l); dbg <- rep(0, l); profs2 <- rep(0, l)#
proft12 <- rep(0, l); proft22 <- rep(0, l); proft32 <- rep(0, l)#
profs12 <- rep(0, l); profs22 <- rep(0, l)#
#################################################################################
# Some functions#
#################################################################################
#
prtS <- function(ps, vS) {#
	a <- vS[vS > ps]#
	val <- length(a) / length(vS)#
	val#
}#
#
DBA <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vA[oneA * (vA - p2A) - p1A > 0      &#
        oneA * (vA - p2A) - p1A >#
        oneG * (vG - p2G) - p1G  &#
        oneA * (vA - p2A) - p1A > #
        oneG * (vG - p2G) - p1LG]#
    out <- length(val) / length(vA)#
    out#
}#
#
DBG <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vG[oneG * (vG - p2G) - p1G > 0 &#
        oneG * (vG - p2G) - p1G  >#
        oneA * (vA - p2A) - p1A           |#
        oneG * (vG - p2G) - p1LG > 0      &#
        oneG * (vG - p2G) - p1LG  >#
        oneA * (vA - p2A) - p1A]#
    out <- length(val) / length(vG)#
    out#
}#
#
DBSam <- function(p1A, p2A, psA, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vG[oneG * (vG - p2G) - p1G > 0 &#
        oneG * (vG - p2G) - p1G  >#
        oneA * (vA - p2A) - p1A]#
    out <- length(val) / length(vG)#
    out#
}#
#
#
DBLG <- function(p1A, p2A, psA, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vG[oneG * (vG - p2G) - p1LG > 0 &#
        oneG * (vG - p2G) - p1LG  >#
        oneA * (vA - p2A) - p1A]#
    out <- length(val) / length(vG)#
    out#
}#
#
NprofitA <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {	one <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS)#
	val <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * prtS(psA, vS) *#
		(p2A + psA - c2) + #
		DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * (p1A - c1)#
	-1 * val#
}#
#
prfAappstore <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {#
	one <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS)#
	val <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * prtS(psA, vS) *#
		(p2A + psA - c2) #
	val#
}#
#
prfAphone <-  function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {	DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS)#
	val <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * (p1A - c1)#
	val#
}#
#
#
NprofitG <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {#
	one <- DBG(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS)#
	val <- DBG(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * prtS(psG, vS) *#
		(p2G + psG - c2) #
	-1 * val#
}#
#
NprofitS <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {#
	val <- DBSam(p1A, p2A, psA, p1G, p2G, psG, vA, vG, vS) *#
		(p1G - c1) #
	-1 * val#
}#
#
NprofitLG <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {#
	val <- DBLG(p1A, p2A, psA, p2G, psG, p1LG, vA, vG, vS) *#
		(p1LG - c1) #
	-1 * val#
}#
############ for welfare#
#
prtSg <- function(ps, vS) {#
    a <- vS[vS > ps]#
    a#
}#
#
wbGg <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vG[oneG * (vG - p2G) - p1G > 0 &#
        oneG * (vG - p2G) - p1G  >#
        oneA * (vA - p2A) - p1A           |#
        oneG * (vG - p2G) - p1LG > 0      &#
        oneG * (vG - p2G) - p1LG  >#
        oneA * (vA - p2A) - p1A]#
    val#
}#
#
wbAg <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vA[oneA * (vA - p2A) - p1A > 0      &#
        oneA * (vA - p2A) - p1A >#
        oneG * (vG - p2G) - p1G  &#
        oneA * (vA - p2A) - p1A > #
        oneG * (vG - p2G) - p1LG]#
    val#
}#
#
#################################################################################
# Equilibrium#
#################################################################################
#
for (m in 1:reps) {#
    #
    p <- vector("list")#
    proft1 <- rep(0, l)#
    proft2 <- rep(0, l)#
    proft3 <- rep(0, l)#
    profs <- rep(0, l)#
    welfA <- matrix(0, nrow = l, ncol = 2)#
    welfG <- matrix(0, nrow = l, ncol = 2)#
    lA <- runif(n, min = 0, max = lbar)#
    lG <- runif(n, min = 0, max = lbar)#
    lS <- runif(n, min = 0, max = lbar)#
    #
    for (i in 1:l) {#
        holder <- vector("list")#
        if (i == 1) {#
            holder[[1]] <- p0#
        } else {#
            holder[[1]] <- p[[i - 1]]  #
        }#
        err <- 1#
        j <- 2 #for indexing iterations of the while loop#
        tempprof <- rep(0, iters)#
        #
        # back and forth for equilibrium#
        while (j < iters) {#
            tp <- holder[[j - 1]] 	#
            fn1 <- function(p1G) {#
                NprofitS(tp[1], tp[2], tp[3], p1G,#
                         tp[5], tp[6], tp[7], lA, lG, lS, c1[i], c2)#
            }#
            fn2 <- function(p1LG) {#
            	NprofitLG(tp[1], tp[2], tp[3], tp[4],#
            			tp[5], tp[6], p1LG, lA, lG, lS, c1[i], c2)#
            }#
            fn3 <- function(p2sG) {#
                NprofitG(tp[1], tp[2], tp[3], tp[4],#
                         p2sG[1], p2sG[2], tp[7], lA, lG, lS, c1[i], c2)#
            }#
            fn4 <- function(p12sA) {#
                NprofitA(p12sA[1], p12sA[2], p12sA[3], tp[4],#
                         tp[5], tp[6], tp[7], lA, lG, lS, c1[i], c2)#
            }#
            opt1 <- optim(tp[4], fn1, method = "L-BFGS-B", #
                          lower = 0.01, upper = lbar) #
            opt2 <- optim(tp[7], fn2, method = "L-BFGS-B", #
                          lower = 0.01, upper = lbar)#
            opt3 <- optim(c(tp[4], tp[5]), fn3, method = "L-BFGS-B", #
                          lower = c(0.01, 0.01), upper = c(lbar, lbar))#
            opt4 <- optim(c(tp[1], tp[2], tp[3]), fn4, #
                          method = "L-BFGS-B", lower = c(0.01, 0.01, 0.01),#
                          upper = c(lbar, lbar, lbar))#
            holder[[j]] <- opt4$par[1]#
            holder[[j]][2] <- opt4$par[2]#
            holder[[j]][3] <- opt4$par[3]#
            holder[[j]][4] <- opt1$par#
            holder[[j]][5] <- opt3$par[1]#
            holder[[j]][6] <- opt3$par[2]#
            holder[[j]][7] <- opt2$par#
            tempprof[j] <- abs(opt4$value) + abs(opt3$value) + #
            	abs(opt1$value) + abs(opt2$value)#
            err <- tempprof[j] - tempprof[j - 1]#
            if (err < tols ) {#
                p[[i]] <- holder[[j]]#
                proft1[i] <- -1 * opt1$value#
                proft2[i] <- -1 * opt2$value#
                proft3[i] <- -1 * opt3$value#
                profs[i] <- -1 * opt4$value                #
                j <- iters#
            } else { #
                j <- j + 1 #
            }#
        }#
        print(c("While Loop step =", i), quote = FALSE)#
    }#
#
    for (i in 1:l) {#
        p1 <- p[[i]][1]#
        p2 <- p[[i]][2]#
        ps <- p[[i]][3]#
        P1 <- p[[i]][4]#
        P2 <- p[[i]][5]#
        PS <- p[[i]][6]#
        PLG <- p[[i]][7]#
        p1A[i] <- p1#
        p1G[i] <- P1#
        p2A[i] <- p2#
        p2G[i] <- P2#
        psA[i] <- ps#
        psG[i] <- PS#
        p1LG[i] <- PLG#
        dba[i] <- DBA(p1, p2, ps, P1, P2, PS, PLG, lA, lG, lS)#
        dbg[i] <- DBG(p1, p2, ps, P1, P2, PS, PLG, lA, lG, lS)#
        profs12[i] <- prfAphone(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
        profs22[i] <- prfAappstore(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
        proft12[i] <- -1 * NprofitS(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
        proft22[i] <- -1 * NprofitLG(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
        proft32[i] <- -1 * NprofitG(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
##
#        AgroupB <-  wbAg(p1, p2, ps, P1, P2, PS, PLG, lA, lG, lS)#
#        GgroupB <-  wbGg(p1, p2, ps, P1, P2, PS, PLG, lA, lG, lS)#
#        AgroupS <- prtSg(ps, lS)#
#        GgroupS <- prtSg(PS, lS)#
#        AutB <- prtS(ps, lS) * (AgroupB - p2) - p1#
#        GutB <- prtS(PS, lS) * (GgroupB - P2) - P1#
#        AutS <- (AgroupS - ps) * dba[i] #
#        GutS <- (GgroupS - PS) * dbg[i]#
#        welfA[i, 1] <- mean(AutB)#
#        welfG[i, 1] <- mean(GutB)#
#        welfA[i, 2] <- mean(AutS)#
#        welfG[i, 2] <- mean(GutS)#
    }#
    #
    print(c("Outer Loop Step =",m), quote = FALSE)#
    #
    fp[,,m] <- cbind(p1A, p1G, p2A, p2G, p1LG, psA, psG)#
    fd[,,m] <- cbind(dba, dbg) #
    fprf[,,m] <- cbind(profs, proft1, proft2, proft3)#
    fprf2[,,m] <- cbind(profs12, profs22, proft12, proft22, proft32)#
    fw[,,m] <- cbind(welfA, welfG)#
#
}#
#
mp <- apply(fp, c(1, 2), mean)#
md <- apply(fd, c(1, 2), mean)#
mprf <- apply(fprf, c(1, 2), mean)#
mprf2 <- apply(fprf2, c(1, 2), mean)#
mw <- apply(fw, c(1, 2), mean)#
#
#
#################################################################################
# Plots#
#################################################################################
# profit #
plot(c1, mprf[, 1], type = "l", lty = 5, col = "blue",#
	xlab = "Cost of Direct Good", ylab = "Profit" )#
lines(c1, mprf[, 2] + mprf[, 3], col = "red")#
#
# welfare#
twA <- mw[, 1] + mw[, 2]#
twG <- mw[, 3] + mw[, 4]#
space <- seq(0.006, 0.6, length.out = length(c1))#
plot(c1, space, type = "n", ylab = "Welfare", xlab = "Cost of Direct Good")#
lines(c1, twA, col = "blue", lty = 5)#
lines(c1, twG, col = "red")#
#
#
# total price #
tpA <- mp[, 1] + mp[, 3] + mp[, 5]#
tpG <- mp[, 2] + mp[, 4] + mp[, 6]#
plot(c1[1:95], tpA[1:95], type = "l", col = "blue", lty = 5, xlab = "Cost of Direct Good", ylab = "Total Price")#
lines(c1[1:95], tpG[1:95], col = "red")#
#
height <- seq(from = 0, to = 1, length.out = 95)#
plot(c1[1:95], height, type = "n", xlab = "Cost of Direct Good", #
	ylab = "Direct Good Price")#
lines(c1[1:95], mp[, 1][1:95], col = "blue", lty = 5)#
lines(c1[1:95], mp[, 2][1:95], col = "red")#
#
height <- seq(from = 0, to = 0.5, length.out = 95)#
plot(c1[1:95], height, type = "n", xlab = "Cost of Direct Good", #
	ylab = "Platform Price to Buyers")#
lines(c1[1:95], mp[, 3][1:95], col = "blue", lty = 5)#
lines(c1[1:95], mp[, 4][1:95], col = "red")#
#
height <- seq(from = 0, to = 0.3, length.out = 95)#
plot(c1[1:95], height, type = "n", xlab = "Cost of Direct Good", #
	ylab = "Platform Price to Sellers")#
lines(c1[1:95], mp[, 5][1:95], col = "blue", lty = 5)#
lines(c1[1:95], mp[, 6][1:95], col = "red")#
#
#
#
# market size#
plot(c1, md[, 1], type = "l", lty = 5, col = "blue", xlab = "Cost of Direct Good", ylab = "Market Sizes")#
lines(c1, md[, 2], col = "red")
mprf2
mprf
plot(mprf2[, 1])
plot(mprf[, 1])
plot(mprf[, 2])
plot(mprf[, 3])
plot(mprf[, 4])
plot(mprf[, 5])
plot(mprf[, 4])
plot(mprf[, 3])
plot(mprf[, 2])
library(Matrix)#
#
#################################################################################
#  Initializations.  Model where sellers can multihome, beta * b = l,#
# competition, and zero fixed costs for sellers.  #
#################################################################################
#
reps <- 5#
lbar <- 1#
num <- 100#
c1 <- seq(0, lbar, length.out = num)#
l <- length(c1)#
c2 <- 0#
n <- 1000#
p0 <- c(0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1)#
iters <- 100#
tols <- 0.001#
fp <- array(0, dim = c(l, 7, reps))#
fd <- array(0, dim = c(l, 2, reps))#
fprf <- array(0, dim = c(l, 4, reps))#
fprf2 <- array(0, dim = c(l, 5, reps))#
fw <- array(0, dim = c(l, 4, reps))#
p1A <- rep(0, l); p2A <- rep(0, l); psA <- rep(0, l)#
p1G <- rep(0, l); p2G <- rep(0, l); psG <- rep(0, l)#
dba <- rep(0, l); dbg <- rep(0, l); profs2 <- rep(0, l)#
proft12 <- rep(0, l); proft22 <- rep(0, l); proft32 <- rep(0, l)#
profs12 <- rep(0, l); profs22 <- rep(0, l)#
#################################################################################
# Some functions#
#################################################################################
#
prtS <- function(ps, vS) {#
	a <- vS[vS > ps]#
	val <- length(a) / length(vS)#
	val#
}#
#
DBA <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vA[oneA * (vA - p2A) - p1A > 0      &#
        oneA * (vA - p2A) - p1A >#
        oneG * (vG - p2G) - p1G  &#
        oneA * (vA - p2A) - p1A > #
        oneG * (vG - p2G) - p1LG]#
    out <- length(val) / length(vA)#
    out#
}#
#
DBG <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vG[oneG * (vG - p2G) - p1G > 0 &#
        oneG * (vG - p2G) - p1G  >#
        oneA * (vA - p2A) - p1A           |#
        oneG * (vG - p2G) - p1LG > 0      &#
        oneG * (vG - p2G) - p1LG  >#
        oneA * (vA - p2A) - p1A]#
    out <- length(val) / length(vG)#
    out#
}#
#
DBSam <- function(p1A, p2A, psA, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vG[oneG * (vG - p2G) - p1G > 0 &#
        oneG * (vG - p2G) - p1G  >#
        oneA * (vA - p2A) - p1A]#
    out <- length(val) / length(vG)#
    out#
}#
#
#
DBLG <- function(p1A, p2A, psA, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vG[oneG * (vG - p2G) - p1LG > 0 &#
        oneG * (vG - p2G) - p1LG  >#
        oneA * (vA - p2A) - p1A]#
    out <- length(val) / length(vG)#
    out#
}#
#
NprofitA <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {	one <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS)#
	val <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * prtS(psA, vS) *#
		(p2A + psA - c2) + #
		DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * (p1A - c1)#
	-1 * val#
}#
#
prfAappstore <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {#
	one <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS)#
	val <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * prtS(psA, vS) *#
		(p2A + psA - c2) #
	val#
}#
#
prfAphone <-  function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {	DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS)#
	val <- DBA(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * (p1A - c1)#
	val#
}#
#
#
NprofitG <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {#
	one <- DBG(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS)#
	val <- DBG(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) * prtS(psG, vS) *#
		(p2G + psG - c2) #
	-1 * val#
}#
#
NprofitS <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {#
	val <- DBSam(p1A, p2A, psA, p1G, p2G, psG, vA, vG, vS) *#
		(p1G - c1) #
	-1 * val#
}#
#
NprofitLG <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS, c1, c2) {#
	val <- DBLG(p1A, p2A, psA, p2G, psG, p1LG, vA, vG, vS) *#
		(p1LG - c1) #
	-1 * val#
}#
############ for welfare#
#
prtSg <- function(ps, vS) {#
    a <- vS[vS > ps]#
    a#
}#
#
wbGg <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vG[oneG * (vG - p2G) - p1G > 0 &#
        oneG * (vG - p2G) - p1G  >#
        oneA * (vA - p2A) - p1A           |#
        oneG * (vG - p2G) - p1LG > 0      &#
        oneG * (vG - p2G) - p1LG  >#
        oneA * (vA - p2A) - p1A]#
    val#
}#
#
wbAg <- function(p1A, p2A, psA, p1G, p2G, psG, p1LG, vA, vG, vS) {#
    oneA <- prtS(psA, vS)#
    oneG <- prtS(psG, vS)#
    val <- vA[oneA * (vA - p2A) - p1A > 0      &#
        oneA * (vA - p2A) - p1A >#
        oneG * (vG - p2G) - p1G  &#
        oneA * (vA - p2A) - p1A > #
        oneG * (vG - p2G) - p1LG]#
    val#
}#
#
#################################################################################
# Equilibrium#
#################################################################################
#
for (m in 1:reps) {#
    #
    p <- vector("list")#
    proft1 <- rep(0, l)#
    proft2 <- rep(0, l)#
    proft3 <- rep(0, l)#
    profs <- rep(0, l)#
    welfA <- matrix(0, nrow = l, ncol = 2)#
    welfG <- matrix(0, nrow = l, ncol = 2)#
    lA <- runif(n, min = 0, max = lbar)#
    lG <- runif(n, min = 0, max = lbar)#
    lS <- runif(n, min = 0, max = lbar)#
    #
    for (i in 1:l) {#
        holder <- vector("list")#
        if (i == 1) {#
            holder[[1]] <- p0#
        } else {#
            holder[[1]] <- p[[i - 1]]  #
        }#
        err <- 1#
        j <- 2 #for indexing iterations of the while loop#
        tempprof <- rep(0, iters)#
        #
        # back and forth for equilibrium#
        while (j < iters) {#
            tp <- holder[[j - 1]] 	#
            fn1 <- function(p1G) {#
                NprofitS(tp[1], tp[2], tp[3], p1G,#
                         tp[5], tp[6], tp[7], lA, lG, lS, c1[i], c2)#
            }#
            fn2 <- function(p1LG) {#
            	NprofitLG(tp[1], tp[2], tp[3], tp[4],#
            			tp[5], tp[6], p1LG, lA, lG, lS, c1[i], c2)#
            }#
            fn3 <- function(p2sG) {#
                NprofitG(tp[1], tp[2], tp[3], tp[4],#
                         p2sG[1], p2sG[2], tp[7], lA, lG, lS, c1[i], c2)#
            }#
            fn4 <- function(p12sA) {#
                NprofitA(p12sA[1], p12sA[2], p12sA[3], tp[4],#
                         tp[5], tp[6], tp[7], lA, lG, lS, c1[i], c2)#
            }#
            opt1 <- optim(tp[4], fn1, method = "L-BFGS-B", #
                          lower = 0.01, upper = lbar) #
            opt2 <- optim(tp[7], fn2, method = "L-BFGS-B", #
                          lower = 0.01, upper = lbar)#
            opt3 <- optim(c(tp[4], tp[5]), fn3, method = "L-BFGS-B", #
                          lower = c(0.01, 0.01), upper = c(lbar, lbar))#
            opt4 <- optim(c(tp[1], tp[2], tp[3]), fn4, #
                          method = "L-BFGS-B", lower = c(0.01, 0.01, 0.01),#
                          upper = c(lbar, lbar, lbar))#
            holder[[j]] <- opt4$par[1]#
            holder[[j]][2] <- opt4$par[2]#
            holder[[j]][3] <- opt4$par[3]#
            holder[[j]][4] <- opt1$par#
            holder[[j]][5] <- opt3$par[1]#
            holder[[j]][6] <- opt3$par[2]#
            holder[[j]][7] <- opt2$par#
            tempprof[j] <- abs(opt4$value) + abs(opt3$value) + #
            	abs(opt1$value) + abs(opt2$value)#
            err <- tempprof[j] - tempprof[j - 1]#
            if (err < tols ) {#
                p[[i]] <- holder[[j]]#
                proft1[i] <- -1 * opt1$value#
                proft2[i] <- -1 * opt2$value#
                proft3[i] <- -1 * opt3$value#
                profs[i] <- -1 * opt4$value                #
                j <- iters#
            } else { #
                j <- j + 1 #
            }#
        }#
        print(c("While Loop step =", i), quote = FALSE)#
    }#
#
    for (i in 1:l) {#
        p1 <- p[[i]][1]#
        p2 <- p[[i]][2]#
        ps <- p[[i]][3]#
        P1 <- p[[i]][4]#
        P2 <- p[[i]][5]#
        PS <- p[[i]][6]#
        PLG <- p[[i]][7]#
        p1A[i] <- p1#
        p1G[i] <- P1#
        p2A[i] <- p2#
        p2G[i] <- P2#
        psA[i] <- ps#
        psG[i] <- PS#
        p1LG[i] <- PLG#
        dba[i] <- DBA(p1, p2, ps, P1, P2, PS, PLG, lA, lG, lS)#
        dbg[i] <- DBG(p1, p2, ps, P1, P2, PS, PLG, lA, lG, lS)#
        profs12[i] <- prfAphone(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
        profs22[i] <- prfAappstore(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
        proft12[i] <- -1 * NprofitS(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
        proft22[i] <- -1 * NprofitLG(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
        proft32[i] <- -1 * NprofitG(p1, p2, ps, P1, P2, PS, PLG,#
        	lA, lG, lS, c1[i], c2)#
##
#        AgroupB <-  wbAg(p1, p2, ps, P1, P2, PS, PLG, lA, lG, lS)#
#        GgroupB <-  wbGg(p1, p2, ps, P1, P2, PS, PLG, lA, lG, lS)#
#        AgroupS <- prtSg(ps, lS)#
#        GgroupS <- prtSg(PS, lS)#
#        AutB <- prtS(ps, lS) * (AgroupB - p2) - p1#
#        GutB <- prtS(PS, lS) * (GgroupB - P2) - P1#
#        AutS <- (AgroupS - ps) * dba[i] #
#        GutS <- (GgroupS - PS) * dbg[i]#
#        welfA[i, 1] <- mean(AutB)#
#        welfG[i, 1] <- mean(GutB)#
#        welfA[i, 2] <- mean(AutS)#
#        welfG[i, 2] <- mean(GutS)#
    }#
    #
    print(c("Outer Loop Step =",m), quote = FALSE)#
    #
    fp[,,m] <- cbind(p1A, p1G, p2A, p2G, p1LG, psA, psG)#
    fd[,,m] <- cbind(dba, dbg) #
    fprf[,,m] <- cbind(profs, proft1, proft2, proft3)#
    fprf2[,,m] <- cbind(profs12, profs22, proft12, proft22, proft32)#
    fw[,,m] <- cbind(welfA, welfG)#
#
}#
#
mp <- apply(fp, c(1, 2), mean)#
md <- apply(fd, c(1, 2), mean)#
mprf <- apply(fprf, c(1, 2), mean)#
mprf2 <- apply(fprf2, c(1, 2), mean)#
mw <- apply(fw, c(1, 2), mean)#
#
#
#################################################################################
# Plots#
#################################################################################
# profit #
plot(c1, mprf[, 1], type = "l", lty = 5, col = "blue",#
	xlab = "Cost of Direct Good", ylab = "Profit" )#
lines(c1, mprf[, 2] + mprf[, 3], col = "red")#
#
# welfare#
twA <- mw[, 1] + mw[, 2]#
twG <- mw[, 3] + mw[, 4]#
space <- seq(0.006, 0.6, length.out = length(c1))#
plot(c1, space, type = "n", ylab = "Welfare", xlab = "Cost of Direct Good")#
lines(c1, twA, col = "blue", lty = 5)#
lines(c1, twG, col = "red")#
#
#
# total price #
tpA <- mp[, 1] + mp[, 3] + mp[, 5]#
tpG <- mp[, 2] + mp[, 4] + mp[, 6]#
plot(c1[1:95], tpA[1:95], type = "l", col = "blue", lty = 5, xlab = "Cost of Direct Good", ylab = "Total Price")#
lines(c1[1:95], tpG[1:95], col = "red")#
#
height <- seq(from = 0, to = 1, length.out = 95)#
plot(c1[1:95], height, type = "n", xlab = "Cost of Direct Good", #
	ylab = "Direct Good Price")#
lines(c1[1:95], mp[, 1][1:95], col = "blue", lty = 5)#
lines(c1[1:95], mp[, 2][1:95], col = "red")#
#
height <- seq(from = 0, to = 0.5, length.out = 95)#
plot(c1[1:95], height, type = "n", xlab = "Cost of Direct Good", #
	ylab = "Platform Price to Buyers")#
lines(c1[1:95], mp[, 3][1:95], col = "blue", lty = 5)#
lines(c1[1:95], mp[, 4][1:95], col = "red")#
#
height <- seq(from = 0, to = 0.3, length.out = 95)#
plot(c1[1:95], height, type = "n", xlab = "Cost of Direct Good", #
	ylab = "Platform Price to Sellers")#
lines(c1[1:95], mp[, 5][1:95], col = "blue", lty = 5)#
lines(c1[1:95], mp[, 6][1:95], col = "red")#
#
#
#
# market size#
plot(c1, md[, 1], type = "l", lty = 5, col = "blue", xlab = "Cost of Direct Good", ylab = "Market Sizes")#
lines(c1, md[, 2], col = "red")
p1
PLG
P1
mprf
plot(mprf[, 1])
plot(mprf[, 2])
plot(mprf[, 3])
plot(mprf[, 4])
plot(mprf[, 2])
plot(mprf[, 1])
points(mprf[, 2])
points(mprf[, 3])
points(mprf[, 4])
a <- mprf[, 1]
b <- mprf[, 2] + mprf[, 3] + mprf[, 4]
plot(a)
points(b)
plot(a, type = "l")
lines(b, col = "red")
mp
p1 <- mp[, 4]
p1 <- mp[, 1]
P1 <- mp[, 5]
P1 <- mp[, 4]
PLG <- mp[, 7]
plot(p1)
lines(P1)
plot(P1)
lines(P1)
plot(P1, type = "l")
lines(p1)
lines(PLG)
plot(PLG)
lines(P1)
lines(p1, col = "blue")
mprf
a
plot(a)
points(b)
plot(a, col = "blue")
lines(b)
plot(a, col = "blue", type = "l")
lines(b)
mprf2
plot[mprf2[, 3]]
plot(mprf2[, 3])
mprf
plot(mprf[, 1])
a <- c(36, 42, 40, 37, 41, 28, 33, 37, 42, 42)
b <- a / 50
b
mean(b)
mean((a + 1) / 50)
mean((a + 2) / 50)
mean((a + 3) / 50)
mean((a + 4) / 50)
end <- a + 4
end
s <- c(41, 45, 39, 40, 38, 43, 35, 39, 44, 34)
mean(s)
39.8/50
s / 50
mean(s / 50)
sp <- s + 1
sp
sp/50
mean(sp/50)
z <- seq(-5, 1, length.out = 100)#
x <- seq(1, 5, length.out = 100)#
z <- exp(z) - max(exp(z))#
x <- log(x[2:length(x)])#
xaxis <- seq(-5, 5, length.out = 199)#
plot(xaxis, 3 + c(z, x), type = "l", xlab = "x-variable", ylab = "Utility")#
segments(0, 0, 0, 3, lty = 3)#
text(-1.3, 3, "Reference Point")
z <- seq(-5, 1, length.out = 100)#
x <- seq(1, 5, length.out = 100)#
z <- exp(z) - max(exp(z))#
x <- log(x[2:length(x)])#
xaxis <- seq(-5, 5, length.out = 199)#
plot(xaxis, 3 + c(z, x), type = "l", xlab = "price", ylab = "Utility")#
segments(0, 0, 0, 3, lty = 3)#
text(-1.3, 3, "Reference Point")
z <- seq(-5, 1, length.out = 100)#
x <- seq(1, 5, length.out = 100)#
z <- exp(z) - max(exp(z)))#
x <- log(x[2:length(x)])#
xaxis <- seq(-5, 5, length.out = 199)#
plot(xaxis, 3 + c(z, x), type = "l", xlab = x-variable", ylab = "Utility")#
segments(0, 0, 0, 3, lty = 3)#
text(-1.3, 3, "Reference Point")
z <- seq(-5, 1, length.out = 100)#
x <- seq(1, 5, length.out = 100)#
z <- exp(z) - max(exp(z)))#
x <- log(x[2:length(x)])#
xaxis <- seq(-5, 5, length.out = 199)#
plot(xaxis, 3 + c(z, x), type = "l", xlab = "x-variable", ylab = "Utility")#
segments(0, 0, 0, 3, lty = 3)#
text(-1.3, 3, "Reference Point")
z <- seq(-5, 1, length.out = 100)#
x <- seq(1, 5, length.out = 100)#
z <- exp(z) - max(exp(z))#
x <- log(x[2:length(x)])#
xaxis <- seq(-5, 5, length.out = 199)#
plot(xaxis, 3 + c(z, x), type = "l", xlab = "x-variable", ylab = "Utility")#
segments(0, 0, 0, 3, lty = 3)#
text(-1.3, 3, "Reference Point")
# Latitude of acceptance#
z <- seq(-5, 1, length.out = 100)#
x <- seq(1, 5, length.out = 100)#
flat <- rep(3, length.out = 10)#
z <- exp(z) - max(exp(z))#
x <- log(x[2:length(x)])#
xaxis <- seq(-5, 5, length.out = 199 + 10)#
plot(xaxis, 3 + c(z, flat - 3, x), type = "l", xlab = "x-variable", ylab = "Utility")#
segments(0, 0, 0, 3, lty = 3)#
text(-1.3, 3, "Reference Point")
# Latitude of acceptance#
z <- seq(-5, 1, length.out = 100)#
x <- seq(1, 5, length.out = 100)#
flat <- rep(3, length.out = 10)#
z <- exp(z) - max(exp(z))#
x <- log(x[2:length(x)])#
xaxis <- seq(-5, 5, length.out = 199 + 10)#
plot(xaxis, 3 + c(z, flat - 3, x), type = "l", xlab = "x-variable", ylab = "Utility")#
segments(0, 0, 0, 3, lty = 3)#
text(-1.3, 3.2, "Reference Point")
#################################################################################
# NOTES:#
# Perhaps the functions could have an argument category, which defaults to #
# all, but if you specify, it would use a subset of relevant items for the #
# sample space. (So more would apply to your problem).#
# In addition, another function could be 'mix', which would suggest items #
# to blend your object or idea with.  I.e. if the category were 'iphone apps'#
# it would have a list of apps like 'angry birds' and 'words with friends.'#
# etc. #
##
# Possible Categories: movie plots or premises, software apps, #
# industrial design, electronic design, marketing, #
# all of the industries in the economy, video games or board games,#
# chemistry, biology, math, econ, maybe business ideas, paintings,#
##
##
#
trans <- c(#
'flip',#
'rotation',#
'resize',#
'in vs. out',#
'analog vs. digital',#
'turn it inside out',#
'3D vs. 2D',#
'push vs. pull',#
'reemphasize' ,#
'reparameterize',#
'micro vs. macro',#
'change of material',#
'change of colors',#
'make it ugly or make it pretty',#
'opt in vs. opt out',#
'flexibility vs. usability',#
'form change',#
'change in control mapping',#
'fixed vs. variable',#
'change in proximity',#
'symmetric vs. asymmetric',#
'conjunctive vs. disjunctive vs. compensatory',#
'mass market vs. niche market',#
'discrete vs. continuous',#
'depth vs. breadth',#
'stretch it out',#
'shrink it down',#
'smooth vs. rough or bumpy'#
)#
#
cons <- c(#
'value curve',#
'symbiosis',#
'what would Gates do?',#
'returns to scale',#
'crowdsourcing',#
'minimalism',#
'aesthetic-usability effect',#
'devils advocate',#
'skunkwerks',#
'thermal mass',#
'compounding',#
'photosynthesis',#
'consumption chain',#
'imitation',#
'survival of the fittest',#
'uncanny valley',#
'form follows function',#
'80/20 rule',#
'accessibility',#
'advance organizer',#
'anthropomorphic form',#
'archetypes',#
'biophilia',#
'chunking',#
'classical conditioning',#
'cognitive dissonance',#
'common fate',#
'contour bias',#
'cost-benefit',#
'design by committee',#
'desire line',#
'exposure effect',#
'halo effect',#
'hawthorne effect',#
'pygmalion effect',#
'placebo effect',#
'rosenthal effect',#
'self-serving bias',#
'feedback loop',#
'fitts law',#
'form follows function',#
'framing',#
'garbage in, garbage out',#
'decision paralysis',#
'hierarchy of needs',#
'horror vacui',#
'iconic representation',#
'flow/immersion',#
'inattentional blindness',#
'interference effects',#
'inverted pyramid',#
'iteration',#
'law of pragnanz',#
'product lifecycle',#
'mental model',#
'modularity',#
'most advanced yet acceptable',#
'most average facial appearance effect',#
'nudge',#
'ochams razor',#
'performance load',#
'performance vs. preference',#
'the use of personas',#
'priming',#
'proggressive disclosure',#
'propositional density',#
'prospect-refuge',#
'scarcity',#
'self-similarity',#
'shaping',#
'signal-to-noise ratio',#
'the power of surprise',#
'the power of concreteness',#
'the power of storytelling',#
'structural forms',#
'wabi-sabi',#
'anchoring and adjusting',#
'consideration sets',#
'drag reduction with spikes',#
'mimicry of nature',#
'natural selection',#
'gains from specialization',#
'make a meta version',#
'loss aversion',#
'risk/reward ratio',#
'randomization',#
'using a controlled trial'#
)#
#
lc <- length(cons)#
lt <- length(trans)#
translate <- function(string = "your object or idea") {#
	tspot <- floor(runif(1, min = 1, max = lt + 1))#
	t <- trans[tspot]#
	a <- paste('for', string, 'try using the translation:', t)#
	cat(a)#
}#
#
blend <- function(string = "your object or idea") {#
	cspot <- floor(runif(1, min = 1, max = lc + 1))#
	c <- cons[cspot]#
	b <- paste('for', string, 'try applying the concept of:', c) #
	cat(b)#
}
busmods <- c(#
'Name your price: Priceline',#
'Offer Aggregation: Kayak, eBay, Amazon',#
'One day, one deal: Groupon',#
'Just-in-time production, or the pull method: Dell, Toyota',#
'Growth first, profit later: Amazon',#
'The Modern Franchise: MCD',#
'Software First: Microsoft',#
'Lifestyle takeover: Apple and Google (the ecosystem idea)',#
'The Everything Store: Walmart',#
'The P2P Revolution: Etsy, Kickstarter, Paypal, Craigslist'#
)
a <- 3
if (a == 2 | a==3) {cat(1)}
if (a == 2 || a==3) {cat(1)}
bm <- function(string = "your object or idea", category = "all") {#
	if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- lbm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- lg[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" | category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- lb[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}#
}
bm()
#################################################################################
# NOTES:#
# Perhaps the functions could have an argument category, which defaults to #
# all, but if you specify, it would use a subset of relevant items for the #
# sample space. (So more would apply to your problem).#
# In addition, another function could be 'mix', which would suggest items #
# to blend your object or idea with.  I.e. if the category were 'iphone apps'#
# it would have a list of apps like 'angry birds' and 'words with friends.'#
# etc. #
##
# Possible Categories: movie plots or premises, software apps, #
# industrial design, electronic design, marketing, #
# all of the industries in the economy, video games or board games,#
# chemistry, biology, math, econ, maybe business ideas, paintings,#
##
##
#
trans <- c(#
'flip',#
'rotation',#
'resize',#
'in vs. out',#
'analog vs. digital',#
'turn it inside out',#
'3D vs. 2D',#
'push vs. pull',#
'reemphasize' ,#
'reparameterize',#
'micro vs. macro',#
'change of material',#
'change of colors',#
'make it ugly or make it pretty',#
'opt in vs. opt out',#
'flexibility vs. usability',#
'form change',#
'change in control mapping',#
'fixed vs. variable',#
'change in proximity',#
'symmetric vs. asymmetric',#
'conjunctive vs. disjunctive vs. compensatory',#
'mass market vs. niche market',#
'discrete vs. continuous',#
'depth vs. breadth',#
'stretch it out',#
'shrink it down',#
'smooth vs. rough or bumpy'#
)#
#
cons <- c(#
'value curve',#
'symbiosis',#
'what would Gates do?',#
'returns to scale',#
'crowdsourcing',#
'minimalism',#
'aesthetic-usability effect',#
'devils advocate',#
'skunkwerks',#
'thermal mass',#
'compounding',#
'photosynthesis',#
'consumption chain',#
'imitation',#
'survival of the fittest',#
'uncanny valley',#
'form follows function',#
'80/20 rule',#
'accessibility',#
'advance organizer',#
'anthropomorphic form',#
'archetypes',#
'biophilia',#
'chunking',#
'classical conditioning',#
'cognitive dissonance',#
'common fate',#
'contour bias',#
'cost-benefit',#
'design by committee',#
'desire line',#
'exposure effect',#
'halo effect',#
'hawthorne effect',#
'pygmalion effect',#
'placebo effect',#
'rosenthal effect',#
'self-serving bias',#
'feedback loop',#
'fitts law',#
'form follows function',#
'framing',#
'garbage in, garbage out',#
'decision paralysis',#
'hierarchy of needs',#
'horror vacui',#
'iconic representation',#
'flow/immersion',#
'inattentional blindness',#
'interference effects',#
'inverted pyramid',#
'iteration',#
'law of pragnanz',#
'product lifecycle',#
'mental model',#
'modularity',#
'most advanced yet acceptable',#
'most average facial appearance effect',#
'nudge',#
'ochams razor',#
'performance load',#
'performance vs. preference',#
'the use of personas',#
'priming',#
'proggressive disclosure',#
'propositional density',#
'prospect-refuge',#
'scarcity',#
'self-similarity',#
'shaping',#
'signal-to-noise ratio',#
'the power of surprise',#
'the power of concreteness',#
'the power of storytelling',#
'structural forms',#
'wabi-sabi',#
'anchoring and adjusting',#
'consideration sets',#
'drag reduction with spikes',#
'mimicry of nature',#
'natural selection',#
'gains from specialization',#
'make a meta version',#
'loss aversion',#
'risk/reward ratio',#
'randomization',#
'using a controlled trial'#
)#
#
busmods <- c(#
'Name your price: Priceline',#
'Offer Aggregation: Kayak, eBay, Amazon',#
'One day, one deal: Groupon',#
'Just-in-time production, or the pull method: Dell, Toyota',#
'Growth first, profit later: Amazon',#
'The Modern Franchise: MCD',#
'Software First: Microsoft',#
'Lifestyle takeover: Apple and Google (the ecosystem idea)',#
'The Everything Store: Walmart',#
'The P2P Revolution: Etsy, Kickstarter, Paypal, Craigslist',#
'Manufacturing Model: you make and sell',#
'Advertiser Model: you get $ from advertising', #
'Data Model: you gather and sell info',#
'Merchant Model: reselling',#
'Brokerage Model: selling knowledge about a service',#
'Affiliate/Commision Model: take a cut of sales you create',#
'Auction Model: gather buyers and sellers',#
'Add-On Model: Razor Blade',#
'Direct Sales (no middle retailer: Warby-Parker)',#
'Freemium, start free and get your info, then mkt till you upgrade',#
'Low-Cost Model: drive volume and try and upsell: Allegiant',#
'Pay-as-you-go: Utilities, micro transactions, financing',#
'All You Can Use/Eat',#
'Basic + Upgrades',#
'Multi Level Marketing',#
'Invent and Licence/get bought',#
'Invent and Startup',#
'Improve and Startup',#
'Improve and Licence/get bought',#
'Crowdsourcing resources')#
#
gamebusmods <- c(#
'Retail: sell boxed games like Nintendo',#
'Digital distribution: Steam, Ninentdo Store',#
'In-Game Adverts: lots of iPhone games pause you to show an ad somewhere',#
'Around-Game Adverts: around the border of the game',#
'Advertgames (like a game built around a brand)',#
'Finder fees from first dollar spend by the found customer',#
'Try before you buy games',#
'Episodic: you buy episodes like expansion quests in warcraft',#
'Skill-based progressive jackpots: pay to enter, win to get the entry fee pool',#
'Velvet Rope or Member’s club: VIP access to stuff',#
'Subscription model',#
'Microtransactions',#
'Sponsored games, usually charity or education',#
'pay per play / pay as you go/ pay for time: like arcade games',#
'Player for player trading of virtual items, you take a cut on auctions',#
'pre-sell distribution rights in marginal countries to fund activities you care about here',#
'Sell info about your players',#
'Freeware: no money, just for fun basically',#
'Loss Leader: freeware or cheapware designed to drive traffic someplace',#
'Peripheral enticement: game cannot function without some hardware, like a gun',#
'player to player wagering: place wagers, go head to head, winner keeps pot, platform keeps a percentage',#
'User generate content: users make content and sell it to each other, you keep a cut or sell time',#
'Pay for storage space to save progress, stats, game data, etc.',#
'Pay for private game server where your friends come to play.  like renting a laser tag place for yourself, or a first person shooter environment',#
'Licensing Access: to play that dumb game at the airport you have to pay a dollar',#
'Selling branded items from your game.  You need a strong identity',#
'Pre-sell game to players: let fans fund dev.  Mighty #9'#
)#
lb <- length(busmods)#
lg <- length(gamebusmods)#
bm <- c(busmods, gamebusmods)#
lbm <- length(bm)#
lc <- length(cons)#
lt <- length(trans)#
translate <- function(string = "your object or idea") {#
	tspot <- floor(runif(1, min = 1, max = lt + 1))#
	t <- trans[tspot]#
	a <- paste('for', string, 'try using the translation:', t)#
	cat(a)#
}
bm()
bm <- function(string = "your object or idea", category = "all") {#
	if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- lbm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- lg[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" | category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- lb[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}#
}
bm('something', 'general')
bm('something', category = 'general')
category <- "general"
if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- lbm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- lg[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" | category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- lb[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}
string <- "your object or idea"
if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- lbm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- lg[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" | category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- lb[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}
category == "general"
lb
spot
element
lb[spot]
spot
lb
bm <- function(string = "your object or idea", category = "all") {#
	if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- lbm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- gamebusmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" | category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- busmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}#
}
bm(
)
bm(string = "your ojbect or idea", category = "all")
spot
lb <- length(busmods)#
lg <- length(gamebusmods)#
abm <- c(busmods, gamebusmods)#
lbm <- length(bm)#
lc <- length(cons)#
lt <- length(trans)#
translate <- function(string = "your object or idea") {#
	tspot <- floor(runif(1, min = 1, max = lt + 1))#
	t <- trans[tspot]#
	a <- paste('for', string, 'try using the translation:', t)#
	cat(a)#
}#
#
bm <- function(string = "your object or idea", category = "all") {#
	if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- abm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- gamebusmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" | category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- busmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}#
}
bm(
)
bm(category = "game")
bm(category = "general")
bm()
bm()
bm()
bm()
spot
remove(spot)
bm <- function(string = "your object or idea", category = "all") {#
	if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- abm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- gamebusmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" | category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- busmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}#
}
bm()
bm()
bm()
bm()
bm()
bm()
spot
abm
abm[17]
lbm
#################################################################################
# NOTES:#
# Perhaps the functions could have an argument category, which defaults to #
# all, but if you specify, it would use a subset of relevant items for the #
# sample space. (So more would apply to your problem).#
# In addition, another function could be 'mix', which would suggest items #
# to blend your object or idea with.  I.e. if the category were 'iphone apps'#
# it would have a list of apps like 'angry birds' and 'words with friends.'#
# etc. #
##
# Possible Categories: movie plots or premises, software apps, #
# industrial design, electronic design, marketing, #
# all of the industries in the economy, video games or board games,#
# chemistry, biology, math, econ, maybe business ideas, paintings,#
##
##
#
trans <- c(#
'flip',#
'rotation',#
'resize',#
'in vs. out',#
'analog vs. digital',#
'turn it inside out',#
'3D vs. 2D',#
'push vs. pull',#
'reemphasize' ,#
'reparameterize',#
'micro vs. macro',#
'change of material',#
'change of colors',#
'make it ugly or make it pretty',#
'opt in vs. opt out',#
'flexibility vs. usability',#
'form change',#
'change in control mapping',#
'fixed vs. variable',#
'change in proximity',#
'symmetric vs. asymmetric',#
'conjunctive vs. disjunctive vs. compensatory',#
'mass market vs. niche market',#
'discrete vs. continuous',#
'depth vs. breadth',#
'stretch it out',#
'shrink it down',#
'smooth vs. rough or bumpy'#
)#
#
cons <- c(#
'value curve',#
'symbiosis',#
'what would Gates do?',#
'returns to scale',#
'crowdsourcing',#
'minimalism',#
'aesthetic-usability effect',#
'devils advocate',#
'skunkwerks',#
'thermal mass',#
'compounding',#
'photosynthesis',#
'consumption chain',#
'imitation',#
'survival of the fittest',#
'uncanny valley',#
'form follows function',#
'80/20 rule',#
'accessibility',#
'advance organizer',#
'anthropomorphic form',#
'archetypes',#
'biophilia',#
'chunking',#
'classical conditioning',#
'cognitive dissonance',#
'common fate',#
'contour bias',#
'cost-benefit',#
'design by committee',#
'desire line',#
'exposure effect',#
'halo effect',#
'hawthorne effect',#
'pygmalion effect',#
'placebo effect',#
'rosenthal effect',#
'self-serving bias',#
'feedback loop',#
'fitts law',#
'form follows function',#
'framing',#
'garbage in, garbage out',#
'decision paralysis',#
'hierarchy of needs',#
'horror vacui',#
'iconic representation',#
'flow/immersion',#
'inattentional blindness',#
'interference effects',#
'inverted pyramid',#
'iteration',#
'law of pragnanz',#
'product lifecycle',#
'mental model',#
'modularity',#
'most advanced yet acceptable',#
'most average facial appearance effect',#
'nudge',#
'ochams razor',#
'performance load',#
'performance vs. preference',#
'the use of personas',#
'priming',#
'proggressive disclosure',#
'propositional density',#
'prospect-refuge',#
'scarcity',#
'self-similarity',#
'shaping',#
'signal-to-noise ratio',#
'the power of surprise',#
'the power of concreteness',#
'the power of storytelling',#
'structural forms',#
'wabi-sabi',#
'anchoring and adjusting',#
'consideration sets',#
'drag reduction with spikes',#
'mimicry of nature',#
'natural selection',#
'gains from specialization',#
'make a meta version',#
'loss aversion',#
'risk/reward ratio',#
'randomization',#
'using a controlled trial'#
)#
#
busmods <- c(#
'Name your price: Priceline',#
'Offer Aggregation: Kayak, eBay, Amazon',#
'One day, one deal: Groupon',#
'Just-in-time production, or the pull method: Dell, Toyota',#
'Growth first, profit later: Amazon',#
'The Modern Franchise: MCD',#
'Software First: Microsoft',#
'Lifestyle takeover: Apple and Google (the ecosystem idea)',#
'The Everything Store: Walmart',#
'The P2P Revolution: Etsy, Kickstarter, Paypal, Craigslist',#
'Manufacturing Model: you make and sell',#
'Advertiser Model: you get $ from advertising', #
'Data Model: you gather and sell info',#
'Merchant Model: reselling',#
'Brokerage Model: selling knowledge about a service',#
'Affiliate/Commision Model: take a cut of sales you create',#
'Auction Model: gather buyers and sellers',#
'Add-On Model: Razor Blade',#
'Direct Sales (no middle retailer: Warby-Parker)',#
'Freemium, start free and get your info, then mkt till you upgrade',#
'Low-Cost Model: drive volume and try and upsell: Allegiant',#
'Pay-as-you-go: Utilities, micro transactions, financing',#
'All You Can Use/Eat',#
'Basic + Upgrades',#
'Multi Level Marketing',#
'Invent and Licence/get bought',#
'Invent and Startup',#
'Improve and Startup',#
'Improve and Licence/get bought',#
'Crowdsourcing resources')#
#
gamebusmods <- c(#
'Retail: sell boxed games like Nintendo',#
'Digital distribution: Steam, Ninentdo Store',#
'In-Game Adverts: lots of iPhone games pause you to show an ad somewhere',#
'Around-Game Adverts: around the border of the game',#
'Advertgames (like a game built around a brand)',#
'Finder fees from first dollar spend by the found customer',#
'Try before you buy games',#
'Episodic: you buy episodes like expansion quests in warcraft',#
'Skill-based progressive jackpots: pay to enter, win to get the entry fee pool',#
'Velvet Rope or Member’s club: VIP access to stuff',#
'Subscription model',#
'Microtransactions',#
'Sponsored games, usually charity or education',#
'pay per play / pay as you go/ pay for time: like arcade games',#
'Player for player trading of virtual items, you take a cut on auctions',#
'pre-sell distribution rights in marginal countries to fund activities you care about here',#
'Sell info about your players',#
'Freeware: no money, just for fun basically',#
'Loss Leader: freeware or cheapware designed to drive traffic someplace',#
'Peripheral enticement: game cannot function without some hardware, like a gun',#
'player to player wagering: place wagers, go head to head, winner keeps pot, platform keeps a percentage',#
'User generate content: users make content and sell it to each other, you keep a cut or sell time',#
'Pay for storage space to save progress, stats, game data, etc.',#
'Pay for private game server where your friends come to play.  like renting a laser tag place for yourself, or a first person shooter environment',#
'Licensing Access: to play that dumb game at the airport you have to pay a dollar',#
'Selling branded items from your game.  You need a strong identity',#
'Pre-sell game to players: let fans fund dev.  Mighty #9'#
)#
lb <- length(busmods)#
lg <- length(gamebusmods)#
abm <- c(busmods, gamebusmods)#
lbm <- length(abm)#
lc <- length(cons)#
lt <- length(trans)#
translate <- function(string = "your object or idea") {#
	tspot <- floor(runif(1, min = 1, max = lt + 1))#
	t <- trans[tspot]#
	a <- paste('for', string, 'try using the translation:', t)#
	cat(a)#
}#
#
bm <- function(string = "your object or idea", category = "all") {#
	if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- abm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- gamebusmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" | category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- busmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}#
}#
#
blend <- function(string = "your object or idea") {#
	cspot <- floor(runif(1, min = 1, max = lc + 1))#
	c <- cons[cspot]#
	b <- paste('for', string, 'try applying the concept of:', c) #
	cat(b)#
}
bm()
bm()
bm()
bm()
bm()
#################################################################################
# NOTES:#
# Perhaps the functions could have an argument category, which defaults to #
# all, but if you specify, it would use a subset of relevant items for the #
# sample space. (So more would apply to your problem).#
# In addition, another function could be 'mix', which would suggest items #
# to blend your object or idea with.  I.e. if the category were 'iphone apps'#
# it would have a list of apps like 'angry birds' and 'words with friends.'#
# etc. #
##
# Possible Categories: movie plots or premises, software apps, #
# industrial design, electronic design, marketing, #
# all of the industries in the economy, video games or board games,#
# chemistry, biology, math, econ, maybe business ideas, paintings,#
##
##
#
trans <- c(#
'flip',#
'rotation',#
'resize',#
'in vs. out',#
'analog vs. digital',#
'turn it inside out',#
'3D vs. 2D',#
'push vs. pull',#
'reemphasize' ,#
'reparameterize',#
'micro vs. macro',#
'change of material',#
'change of colors',#
'make it ugly or make it pretty',#
'opt in vs. opt out',#
'flexibility vs. usability',#
'form change',#
'change in control mapping',#
'fixed vs. variable',#
'change in proximity',#
'symmetric vs. asymmetric',#
'conjunctive vs. disjunctive vs. compensatory',#
'mass market vs. niche market',#
'discrete vs. continuous',#
'depth vs. breadth',#
'stretch it out',#
'shrink it down',#
'smooth vs. rough or bumpy'#
)#
#
cons <- c(#
'value curve',#
'symbiosis',#
'what would Gates do?',#
'returns to scale',#
'crowdsourcing',#
'minimalism',#
'aesthetic-usability effect',#
'devils advocate',#
'skunkwerks',#
'thermal mass',#
'compounding',#
'photosynthesis',#
'consumption chain',#
'imitation',#
'survival of the fittest',#
'uncanny valley',#
'form follows function',#
'80/20 rule',#
'accessibility',#
'advance organizer',#
'anthropomorphic form',#
'archetypes',#
'biophilia',#
'chunking',#
'classical conditioning',#
'cognitive dissonance',#
'common fate',#
'contour bias',#
'cost-benefit',#
'design by committee',#
'desire line',#
'exposure effect',#
'halo effect',#
'hawthorne effect',#
'pygmalion effect',#
'placebo effect',#
'rosenthal effect',#
'self-serving bias',#
'feedback loop',#
'fitts law',#
'form follows function',#
'framing',#
'garbage in, garbage out',#
'decision paralysis',#
'hierarchy of needs',#
'horror vacui',#
'iconic representation',#
'flow/immersion',#
'inattentional blindness',#
'interference effects',#
'inverted pyramid',#
'iteration',#
'law of pragnanz',#
'product lifecycle',#
'mental model',#
'modularity',#
'most advanced yet acceptable',#
'most average facial appearance effect',#
'nudge',#
'ochams razor',#
'performance load',#
'performance vs. preference',#
'the use of personas',#
'priming',#
'proggressive disclosure',#
'propositional density',#
'prospect-refuge',#
'scarcity',#
'self-similarity',#
'shaping',#
'signal-to-noise ratio',#
'the power of surprise',#
'the power of concreteness',#
'the power of storytelling',#
'structural forms',#
'wabi-sabi',#
'anchoring and adjusting',#
'consideration sets',#
'drag reduction with spikes',#
'mimicry of nature',#
'natural selection',#
'gains from specialization',#
'make a meta version',#
'loss aversion',#
'risk/reward ratio',#
'randomization',#
'using a controlled trial'#
)#
#
busmods <- c(#
'Name your price: Priceline',#
'Offer Aggregation: Kayak, eBay, Amazon',#
'One day, one deal: Groupon',#
'Just-in-time production, or the pull method: Dell, Toyota',#
'Growth first, profit later: Amazon',#
'The Modern Franchise: MCD',#
'Software First: Microsoft',#
'Lifestyle takeover: Apple and Google (the ecosystem idea)',#
'The Everything Store: Walmart',#
'The P2P Revolution: Etsy, Kickstarter, Paypal, Craigslist',#
'Manufacturing Model: you make and sell',#
'Advertiser Model: you get $ from advertising', #
'Data Model: you gather and sell info',#
'Merchant Model: reselling',#
'Brokerage Model: selling knowledge about a service',#
'Affiliate/Commision Model: take a cut of sales you create',#
'Auction Model: gather buyers and sellers',#
'Add-On Model: Razor Blade',#
'Direct Sales (no middle retailer: Warby-Parker)',#
'Freemium, start free and get your info, then mkt till you upgrade',#
'Low-Cost Model: drive volume and try and upsell: Allegiant',#
'Pay-as-you-go: Utilities, micro transactions, financing',#
'All You Can Use/Eat',#
'Basic + Upgrades',#
'Multi Level Marketing',#
'Invent and Licence/get bought',#
'Invent and Startup',#
'Improve and Startup',#
'Improve and Licence/get bought',#
'Crowdsourcing resources')#
#
gamebusmods <- c(#
'Retail: sell boxed games like Nintendo',#
'Digital distribution: Steam, Ninentdo Store',#
'In-Game Adverts: lots of iPhone games pause you to show an ad somewhere',#
'Around-Game Adverts: around the border of the game',#
'Advertgames (like a game built around a brand)',#
'Finder fees from first dollar spend by the found customer',#
'Try before you buy games',#
'Episodic: you buy episodes like expansion quests in warcraft',#
'Skill-based progressive jackpots: pay to enter, win to get the entry fee pool',#
'Velvet Rope or Member’s club: VIP access to stuff',#
'Subscription model',#
'Microtransactions',#
'Sponsored games, usually charity or education',#
'pay per play / pay as you go/ pay for time: like arcade games',#
'Player for player trading of virtual items, you take a cut on auctions',#
'pre-sell distribution rights in marginal countries to fund activities you care about here',#
'Sell info about your players',#
'Loss Leader: freeware or cheapware designed to drive traffic someplace',#
'Peripheral enticement: game cannot function without some hardware, like a gun',#
'player to player wagering: place wagers, go head to head, winner keeps pot, platform keeps a percentage',#
'User generate content: users make content and sell it to each other, you keep a cut or sell time',#
'Pay for storage space to save progress, stats, game data, etc.',#
'Pay for private game server where your friends come to play.  like renting a laser tag place for yourself, or a first person shooter environment',#
'Licensing Access: to play that dumb game at the airport you have to pay a dollar',#
'Selling branded items from your game.  You need a strong identity',#
'Pre-sell game to players: let fans fund dev.  Mighty #9'#
)#
lb <- length(busmods)#
lg <- length(gamebusmods)#
abm <- c(busmods, gamebusmods)#
lbm <- length(abm)#
lc <- length(cons)#
lt <- length(trans)#
translate <- function(string = "your object or idea") {#
	tspot <- floor(runif(1, min = 1, max = lt + 1))#
	t <- trans[tspot]#
	a <- paste('for', string, 'try using the translation:', t)#
	cat(a)#
}#
#
bm <- function(string = "your object or idea", category = "all") {#
	if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- abm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- gamebusmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" | category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- busmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}#
}#
#
blend <- function(string = "your object or idea") {#
	cspot <- floor(runif(1, min = 1, max = lc + 1))#
	c <- cons[cspot]#
	b <- paste('for', string, 'try applying the concept of:', c) #
	cat(b)#
}
bm()
bm()
bm()
bm()
??rtf
getwd()
setwd('/Users/jasonbell/Desktop/Ideas/Creativity Toolbox/IdeaBlender')
test <- read.table(concepts.txt)
getwd()
test <- read.table('concepts.txt')
test <- read.table('concepts.txt', sep = ";")
test <- read.table('concepts.txt', sep = ";", header = TRUE)
test <- read.table('concepts.txt', header = TRUE)
test <- read.table('concepts.txt', header = TRUE)
?read.table
test <- read.table('concepts.txt', header = TRUE)
a
b
b <- "something"
class(b
)
test <- read.table('concepts.txt', header = TRUE, colClasses = c("character"))
count.fields('concepts.txt')
test <- read.table('concepts.txt', header = TRUE, sep = "&")
test
s
count.fields('concepts.txt')
test <- read.table('concepts.txt', header = TRUE, sep = "&")
test
test <- read.table('concepts.txt', header = TRUE, sep = "&")
test
test[6]
test[6, ]
test[1:5, ] <- NULL
test
test[1, ]
test[1:5, ] <- NULL
test <- [6:nrow(test), ]
test <- test[6:nrow(test), ]
test[1, ]
test
test[1]
test <- read.table("concepts.txt", header = FALSE, colnames = c("Concepts"), sep = "&")
test <- read.table("concepts.txt", header = FALSE, col.names = c("Concepts"), sep = "&")
test
test[73, ]
test <- read.table("concepts.txt", header = FALSE, col.names = c("Concepts"), sep = "&")
test
test <- read.table("concepts.txt", header = FALSE, col.names = c("Concepts"), sep = "\\")
test <- read.table("concepts.txt", header = FALSE, col.names = c("Concepts", "Backslashes"), sep = "\\")
count.fields("concepts.txt", sep = "\\")
test <- read.table("concepts.txt", header = FALSE, col.names = c("Concepts"), sep = "&")
test
test
test2 <- test
test2 <- as.vector(test)
test2
test2[1]
length(test2)
remove(test2)
test
test <- read.table("concepts.txt")
test
test[1, ]
test <- read.table("concepts.txt", header = TRUE)
test
test <- read.table("concepts.txt", header = TRUE, quote = "\"")
test
cons <- read.table("concepts.txt", header = TRUE, quote = "\"")#
cons <- cons[1:length(cons), ]
cons
length(cons)
cons <- read.table("concepts.txt", header = TRUE, quote = "\"")
const
cons
dim(cons)
cons[1:90, ]
test <- cons[1:90, ]
test
length(test)
cons[, 1]
cons <- read.table("concepts.txt", header = TRUE, quote = "\"")#
cons <- cons[, 1]
cons
length(cons)
dim(cons)
str(cons)
lc <- length(cons)
blend <- function(string = "your object or idea") {#
	cspot <- floor(runif(1, min = 1, max = lc + 1))#
	c <- cons[cspot]#
	b <- paste('for', string, 'try applying the concept of:', c) #
	cat(b)#
}
blend()
trans <- read.table("translations.txt", header = TRUE, quote = "\"")#
trans <- trans[, 1]
#
cons <- read.table("concepts.txt", header = TRUE, quote = "\"")#
cons <- cons[, 1]#
trans <- read.table("translations.txt", header = TRUE, quote = "\"")#
trans <- trans[, 1]#
lc <- length(cons)#
lt <- length(trans)#
translate <- function(string = "your object or idea") {#
	tspot <- floor(runif(1, min = 1, max = lt + 1))#
	t <- trans[tspot]#
	a <- paste('for', string, 'try using the translation:', t)#
	cat(a)#
}#
#
#
#
blend <- function(string = "your object or idea") {#
	cspot <- floor(runif(1, min = 1, max = lc + 1))#
	c <- cons[cspot]#
	b <- paste('for', string, 'try applying the concept of:', c) #
	cat(b)#
}
translate()
busmods <- read.table("BusinessModels.txt", header = TRUE, quote = "\"")[, 1]
busmods
gamebusmods <- read.table("GamingBusinessModels.txt", header = TRUE, quote = "\"")[, 1]
gamebusmods
gamebusmods
gamebusmods
cons <- read.table("concepts.txt", header = TRUE, quote = "\"", stringsAsFactors = FALSE)[, 1]
cons
length(cons)
lc <- length(cons)#
lt <- length(trans)
blend <- function(string = "your object or idea") {#
	cspot <- floor(runif(1, min = 1, max = lc + 1))#
	c <- cons[cspot]#
	b <- paste('for', string, 'try applying the concept of:', c) #
	cat(b)#
}
blend()
#################################################################################
# NOTES:#
# Perhaps the functions could have an argument category, which defaults to #
# all, but if you specify, it would use a subset of relevant items for the #
# sample space. (So more would apply to your problem).#
# In addition, another function could be 'mix', which would suggest items #
# to blend your object or idea with.  I.e. if the category were 'iphone apps'#
# it would have a list of apps like 'angry birds' and 'words with friends.'#
# etc. #
##
# Possible Categories: movie plots or premises, software apps, #
# industrial design, electronic design, marketing, #
# all of the industries in the economy, video games or board games,#
# chemistry, biology, math, econ, maybe business ideas, paintings,#
##
#################################################################################
#
setwd('/Users/jasonbell/Desktop/Ideas/Creativity Toolbox/IdeaBlender')#
cons <- read.table("concepts.txt", header = TRUE, quote = "\"", #
	stringsAsFactors = FALSE)[, 1]#
trans <- read.table("translations.txt", header = TRUE, quote = "\"", #
	stringsAsFactors = FALSE)[, 1]#
lc <- length(cons)#
lt <- length(trans)#
#
#
busmods <- read.table("BusinessModels.txt", header = TRUE, #
	quote = "\"", stringsAsFactors = FALSE)[, 1]#
gamebusmods <- read.table("GamingBusinessModels.txt", header = TRUE, #
	quote = "\"", stringsAsFactors = FALSE)[, 1]#
lb <- length(busmods)#
lg <- length(gamebusmods)#
abm <- c(busmods, gamebusmods)#
lbm <- length(abm)#
#
#################################################################################
#  Functions#
#################################################################################
#
translate <- function(string = "your object or idea") {#
	tspot <- floor(runif(1, min = 1, max = lt + 1))#
	t <- trans[tspot]#
	a <- paste('for', string, 'try using the translation:', t)#
	cat(a)#
}#
#
blend <- function(string = "your object or idea") {#
	cspot <- floor(runif(1, min = 1, max = lc + 1))#
	c <- cons[cspot]#
	b <- paste('for', string, 'try applying the concept of:', c) #
	cat(b)#
}#
#
bm <- function(string = "your object or idea", category = "all") {#
	if (category == "all") {#
		spot <- floor(runif(1, min = 1, max = lbm + 1))#
		element <- abm[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "games" | category == "game") {#
		spot <- floor(runif(1, min = 1, max = lg + 1))#
		element <- gamebusmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else if (category == "business models" | category == "business" |#
	category == "general") {#
		spot <- floor(runif(1, min = 1, max = lb + 1))#
		element <- busmods[spot]#
		a <- paste('for', string, 'try', element)#
		cat(a)	#
	} else {error('invalid category')}#
}
blend()
blend()
