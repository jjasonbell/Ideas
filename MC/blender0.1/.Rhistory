csMat[r, j] <- ifelse(sum(X[j, ] < gMat[r, ]) == 0, 1, 0)
}
}
V <- matrix(0, nrow = nc, ncol = nrule)
for (n in 1:nc) {
for (r in 1:nrule) {
index <- csMat[r, ] * 1:nalt
csize <- sum(csMat[r, ])
exMax <- log(sum(exp(ua[n, index]))) - lambda * csize
V[n, r] <- exMax + rgumbel(1, loc = -0.57722)
}
}
# Generates rule choice and resulting csets
s <- rep(0, nc)
csets <- matrix(0, nrow = nc, ncol = nalt)
for (n in 1:nc) {
s[n] <- which.max(V[n, ])
csets[n, ] <- csMat[s[n], ]
}
#-------------------------------------------------------------------------------
# Estimation
#-------------------------------------------------------------------------------
csMat2 <- unique(csMat)
nrule2 <- nrow(csMat2)
s2 <- rep(0, nc)
for (n in 1:nc) {
row <- 0
for (r in 1:nrow(csMat2)) {
if (sum(csMat[s[n], ] != csMat2[r, ]) == 0) row <- r
}
s2[n] <- row
}
tTheta <- c(alpha, lambda)
eTheta <- rep(1, length(tTheta))
ll <- function(eTheta) {
alpha <- eTheta[1:2]
lambda <- eTheta[3]
ualts <- Z[, 1] * alpha[1] + Z[, 2] * alpha[2]
Vs <- rep(0, nrule2)
for (r in 1:nrule2) {
index <- csMat2[r, ] * 1:nalt
csize <- sum(csMat2[r, ])
Vs[r] <- exp(-lambda * csize) * sum(exp(ualts[index]))
}
lln <- rep(0, nc)
for (n in 1:nc) {
pn <- Vs / sum(Vs)
lln[n] <- log(pn[s2[n]]) + sum(log(1 - pn[-s2[n]]))
}
ll_out <- sum(lln)
ll_out
}
opt <- optim(eTheta, ll, control = list(fnscale = -1))
table <- matrix(0, ncol = length(tTheta), nrow = 2)
table[1, ] <- tTheta
table[2, ] <- opt$par
rownames(table) <- c("True", "Estimate")
colnames(table) <- c("alpha1", "alpha2", "lambda")
table
library(evd)
#-------------------------------------------------------------------------------
# Simulation
#-------------------------------------------------------------------------------
nalt <- 6
nrule <- 8
nc <- 1000
alpha <- c(2, -1)
lambda <- 1
# gamma: compact, small, medium;  car, truck;  toyota, honda, ford
gamma <- c(0, 0.5, 0, 0.5, 0, 0.5, 0, 0)
Z <- cbind(rnorm(nalt), rnorm(nalt))
ua <- Z[, 1] * alpha[1] + Z[, 2] * alpha[2]
ua <- matrix(ua, nrow = nc, ncol = nalt, byrow = T) # homogeneous agents
X <- matrix(0, nrow = nalt, ncol = nrule)
rownames(X) <- c("Corolla", "Camry", "Civic", "Accord", "Fusion", "F-150")
X[, 1] <- c(1, 0, 1, 0, 0, 0) # compact
X[, 2] <- c(0, 1, 0, 1, 1, 0) # small
X[, 3] <- c(0, 0, 0, 0, 0, 1) # medium
X[, 4] <- c(1, 1, 1, 1, 1, 0) # car
X[, 5] <- c(0, 0, 0, 0, 0, 1) # truck
X[, 6] <- c(1, 1, 0, 0, 0, 0) # toyota
X[, 7] <- c(0, 0, 1, 1, 0, 0) # honda
X[, 8] <- c(0, 0, 0, 0, 1, 1) # ford
colnames(X) <- c("Compact", "Small", "Medium", "Car",
"Truck", "Toyota", "Honda", "Ford")
iList <- list() # use to grab the right spot in gamma
iList[[1]] <- 1:3
iList[[2]] <- 4:5
iList[[3]] <- 6:8
# could do the following with a double loop and use combinat::combn
gMat <- matrix(0, nrow = nrule, ncol = length(gamma))
gMat[2, iList[[1]]] <- gamma[iList[[1]]]
gMat[3, iList[[2]]] <- gamma[iList[[2]]]
gMat[4, iList[[3]]] <- gamma[iList[[3]]]
gMat[5, c(iList[[1]], iList[[2]])] <- gamma[c(iList[[1]], iList[[2]])]
gMat[6, c(iList[[1]], iList[[3]])] <- gamma[c(iList[[1]], iList[[3]])]
gMat[7, c(iList[[2]], iList[[3]])] <- gamma[c(iList[[2]], iList[[3]])]
gMat[8, ] <- gamma
csMat <- matrix(0, nrow = nrule, ncol = nalt)
for (r in 1:nrule) {
for (j in 1:nalt) {
csMat[r, j] <- ifelse(sum(X[j, ] < gMat[r, ]) == 0, 1, 0)
}
}
V <- matrix(0, nrow = nc, ncol = nrule)
for (n in 1:nc) {
for (r in 1:nrule) {
index <- csMat[r, ] * 1:nalt
csize <- sum(csMat[r, ])
exMax <- log(sum(exp(ua[n, index]))) - lambda * csize
V[n, r] <- exMax + rgumbel(1, loc = -0.57722)
}
}
# Generates rule choice and resulting csets
s <- rep(0, nc)
csets <- matrix(0, nrow = nc, ncol = nalt)
for (n in 1:nc) {
s[n] <- which.max(V[n, ])
csets[n, ] <- csMat[s[n], ]
}
#-------------------------------------------------------------------------------
# Estimation
#-------------------------------------------------------------------------------
csMat2 <- unique(csMat)
nrule2 <- nrow(csMat2)
s2 <- rep(0, nc)
for (n in 1:nc) {
row <- 0
for (r in 1:nrow(csMat2)) {
if (sum(csMat[s[n], ] != csMat2[r, ]) == 0) row <- r
}
s2[n] <- row
}
tTheta <- c(alpha, lambda)
eTheta <- rep(1, length(tTheta))
ll <- function(eTheta) {
alpha <- eTheta[1:2]
lambda <- eTheta[3]
ualts <- Z[, 1] * alpha[1] + Z[, 2] * alpha[2]
Vs <- rep(0, nrule2)
for (r in 1:nrule2) {
index <- csMat2[r, ] * 1:nalt
csize <- sum(csMat2[r, ])
Vs[r] <- exp(-lambda * csize) * sum(exp(ualts[index]))
}
lln <- rep(0, nc)
for (n in 1:nc) {
pn <- Vs / sum(Vs)
lln[n] <- log(pn[s2[n]]) + sum(log(1 - pn[-s2[n]]))
}
ll_out <- sum(lln)
ll_out
}
opt <- optim(eTheta, ll, control = list(fnscale = -1))
table <- matrix(0, ncol = length(tTheta), nrow = 2)
table[1, ] <- tTheta
table[2, ] <- opt$par
rownames(table) <- c("True", "Estimate")
colnames(table) <- c("alpha1", "alpha2", "lambda")
table
library(evd)
#-------------------------------------------------------------------------------
# Simulation
#-------------------------------------------------------------------------------
nalt <- 6
nrule <- 8
nc <- 1000
alpha <- c(2, -1)
lambda <- 1
# gamma: compact, small, medium;  car, truck;  toyota, honda, ford
gamma <- c(0, 0.5, 0, 0.5, 0, 0.5, 0, 0)
Z <- cbind(rnorm(nalt), rnorm(nalt))
ua <- Z[, 1] * alpha[1] + Z[, 2] * alpha[2]
ua <- matrix(ua, nrow = nc, ncol = nalt, byrow = T) # homogeneous agents
X <- matrix(0, nrow = nalt, ncol = nrule)
rownames(X) <- c("Corolla", "Camry", "Civic", "Accord", "Fusion", "F-150")
X[, 1] <- c(1, 0, 1, 0, 0, 0) # compact
X[, 2] <- c(0, 1, 0, 1, 1, 0) # small
X[, 3] <- c(0, 0, 0, 0, 0, 1) # medium
X[, 4] <- c(1, 1, 1, 1, 1, 0) # car
X[, 5] <- c(0, 0, 0, 0, 0, 1) # truck
X[, 6] <- c(1, 1, 0, 0, 0, 0) # toyota
X[, 7] <- c(0, 0, 1, 1, 0, 0) # honda
X[, 8] <- c(0, 0, 0, 0, 1, 1) # ford
colnames(X) <- c("Compact", "Small", "Medium", "Car",
"Truck", "Toyota", "Honda", "Ford")
iList <- list() # use to grab the right spot in gamma
iList[[1]] <- 1:3
iList[[2]] <- 4:5
iList[[3]] <- 6:8
# could do the following with a double loop and use combinat::combn
gMat <- matrix(0, nrow = nrule, ncol = length(gamma))
gMat[2, iList[[1]]] <- gamma[iList[[1]]]
gMat[3, iList[[2]]] <- gamma[iList[[2]]]
gMat[4, iList[[3]]] <- gamma[iList[[3]]]
gMat[5, c(iList[[1]], iList[[2]])] <- gamma[c(iList[[1]], iList[[2]])]
gMat[6, c(iList[[1]], iList[[3]])] <- gamma[c(iList[[1]], iList[[3]])]
gMat[7, c(iList[[2]], iList[[3]])] <- gamma[c(iList[[2]], iList[[3]])]
gMat[8, ] <- gamma
csMat <- matrix(0, nrow = nrule, ncol = nalt)
for (r in 1:nrule) {
for (j in 1:nalt) {
csMat[r, j] <- ifelse(sum(X[j, ] < gMat[r, ]) == 0, 1, 0)
}
}
V <- matrix(0, nrow = nc, ncol = nrule)
for (n in 1:nc) {
for (r in 1:nrule) {
index <- csMat[r, ] * 1:nalt
csize <- sum(csMat[r, ])
exMax <- log(sum(exp(ua[n, index]))) - lambda * csize
V[n, r] <- exMax + rgumbel(1, loc = -0.57722)
}
}
# Generates rule choice and resulting csets
s <- rep(0, nc)
csets <- matrix(0, nrow = nc, ncol = nalt)
for (n in 1:nc) {
s[n] <- which.max(V[n, ])
csets[n, ] <- csMat[s[n], ]
}
#-------------------------------------------------------------------------------
# Estimation
#-------------------------------------------------------------------------------
csMat2 <- unique(csMat)
nrule2 <- nrow(csMat2)
s2 <- rep(0, nc)
for (n in 1:nc) {
row <- 0
for (r in 1:nrow(csMat2)) {
if (sum(csMat[s[n], ] != csMat2[r, ]) == 0) row <- r
}
s2[n] <- row
}
tTheta <- c(alpha, lambda)
eTheta <- rep(1, length(tTheta))
ll <- function(eTheta) {
alpha <- eTheta[1:2]
lambda <- eTheta[3]
ualts <- Z[, 1] * alpha[1] + Z[, 2] * alpha[2]
Vs <- rep(0, nrule2)
for (r in 1:nrule2) {
index <- csMat2[r, ] * 1:nalt
csize <- sum(csMat2[r, ])
Vs[r] <- exp(-lambda * csize) * sum(exp(ualts[index]))
}
lln <- rep(0, nc)
for (n in 1:nc) {
pn <- Vs / sum(Vs)
lln[n] <- log(pn[s2[n]]) + sum(log(1 - pn[-s2[n]]))
}
ll_out <- sum(lln)
ll_out
}
opt <- optim(eTheta, ll, control = list(fnscale = -1))
table <- matrix(0, ncol = length(tTheta), nrow = 2)
table[1, ] <- tTheta
table[2, ] <- opt$par
rownames(table) <- c("True", "Estimate")
colnames(table) <- c("alpha1", "alpha2", "lambda")
table
library(evd)
#-------------------------------------------------------------------------------
# Simulation
#-------------------------------------------------------------------------------
nalt <- 6
nrule <- 8
nc <- 1000
alpha <- c(2, -1)
lambda <- 1
# gamma: compact, small, medium;  car, truck;  toyota, honda, ford
gamma <- c(0, 0.5, 0, 0.5, 0, 0.5, 0, 0)
Z <- cbind(rnorm(nalt), rnorm(nalt))
ua <- Z[, 1] * alpha[1] + Z[, 2] * alpha[2]
ua <- matrix(ua, nrow = nc, ncol = nalt, byrow = T) # homogeneous agents
X <- matrix(0, nrow = nalt, ncol = nrule)
rownames(X) <- c("Corolla", "Camry", "Civic", "Accord", "Fusion", "F-150")
X[, 1] <- c(1, 0, 1, 0, 0, 0) # compact
X[, 2] <- c(0, 1, 0, 1, 1, 0) # small
X[, 3] <- c(0, 0, 0, 0, 0, 1) # medium
X[, 4] <- c(1, 1, 1, 1, 1, 0) # car
X[, 5] <- c(0, 0, 0, 0, 0, 1) # truck
X[, 6] <- c(1, 1, 0, 0, 0, 0) # toyota
X[, 7] <- c(0, 0, 1, 1, 0, 0) # honda
X[, 8] <- c(0, 0, 0, 0, 1, 1) # ford
colnames(X) <- c("Compact", "Small", "Medium", "Car",
"Truck", "Toyota", "Honda", "Ford")
iList <- list() # use to grab the right spot in gamma
iList[[1]] <- 1:3
iList[[2]] <- 4:5
iList[[3]] <- 6:8
# could do the following with a double loop and use combinat::combn
gMat <- matrix(0, nrow = nrule, ncol = length(gamma))
gMat[2, iList[[1]]] <- gamma[iList[[1]]]
gMat[3, iList[[2]]] <- gamma[iList[[2]]]
gMat[4, iList[[3]]] <- gamma[iList[[3]]]
gMat[5, c(iList[[1]], iList[[2]])] <- gamma[c(iList[[1]], iList[[2]])]
gMat[6, c(iList[[1]], iList[[3]])] <- gamma[c(iList[[1]], iList[[3]])]
gMat[7, c(iList[[2]], iList[[3]])] <- gamma[c(iList[[2]], iList[[3]])]
gMat[8, ] <- gamma
csMat <- matrix(0, nrow = nrule, ncol = nalt)
for (r in 1:nrule) {
for (j in 1:nalt) {
csMat[r, j] <- ifelse(sum(X[j, ] < gMat[r, ]) == 0, 1, 0)
}
}
V <- matrix(0, nrow = nc, ncol = nrule)
for (n in 1:nc) {
for (r in 1:nrule) {
index <- csMat[r, ] * 1:nalt
csize <- sum(csMat[r, ])
exMax <- log(sum(exp(ua[n, index]))) - lambda * csize
V[n, r] <- exMax + rgumbel(1, loc = -0.57722)
}
}
# Generates rule choice and resulting csets
s <- rep(0, nc)
csets <- matrix(0, nrow = nc, ncol = nalt)
for (n in 1:nc) {
s[n] <- which.max(V[n, ])
csets[n, ] <- csMat[s[n], ]
}
#-------------------------------------------------------------------------------
# Estimation
#-------------------------------------------------------------------------------
csMat2 <- unique(csMat)
nrule2 <- nrow(csMat2)
s2 <- rep(0, nc)
for (n in 1:nc) {
row <- 0
for (r in 1:nrow(csMat2)) {
if (sum(csMat[s[n], ] != csMat2[r, ]) == 0) row <- r
}
s2[n] <- row
}
tTheta <- c(alpha, lambda)
eTheta <- rep(1, length(tTheta))
ll <- function(eTheta) {
alpha <- eTheta[1:2]
lambda <- eTheta[3]
ualts <- Z[, 1] * alpha[1] + Z[, 2] * alpha[2]
Vs <- rep(0, nrule2)
for (r in 1:nrule2) {
index <- csMat2[r, ] * 1:nalt
csize <- sum(csMat2[r, ])
Vs[r] <- exp(-lambda * csize) * sum(exp(ualts[index]))
}
lln <- rep(0, nc)
for (n in 1:nc) {
pn <- Vs / sum(Vs)
lln[n] <- log(pn[s2[n]]) + sum(log(1 - pn[-s2[n]]))
}
ll_out <- sum(lln)
ll_out
}
opt <- optim(eTheta, ll, control = list(fnscale = -1))
table <- matrix(0, ncol = length(tTheta), nrow = 2)
table[1, ] <- tTheta
table[2, ] <- opt$par
rownames(table) <- c("True", "Estimate")
colnames(table) <- c("alpha1", "alpha2", "lambda")
table
library(xtbale)
library(xtable)
xtable(matrix(0, 3, 3))
xtable(matrix(0, 8, 10))
??"integer program"
#
# Set up problem: maximize
#   x1 + 9 x2 +   x3 subject to
#   x1 + 2 x2 + 3 x3  <= 9
# 3 x1 + 2 x2 + 2 x3 <= 15
#
f.obj <- c(1, 9, 1)
f.con <- matrix (c(1, 2, 3, 3, 2, 2), nrow=2, byrow=TRUE)
f.dir <- c("<=", "<=")
f.rhs <- c(9, 15)
f.obj
f.con
f.dir
f.rhs
lp ("max", f.obj, f.con, f.dir, f.rhs)
lp ("max", f.obj, f.con, f.dir, f.rhs)
library(lpSolve)
lp ("max", f.obj, f.con, f.dir, f.rhs)
s <- lp ("max", f.obj, f.con, f.dir, f.rhs)
s
names(s)
s$direction
s$x.count
s$int.vec
s$solution
gplot(rgraph(5))               #Plot a random graph
library(sna)
gplot(rgraph(5))               #Plot a random graph
gplot(rgraph(5),usecurv=TRUE)  #This time, use curved edges
gplot(rgraph(5),mode="mds")    #Try an alternative layout scheme
gplot(rgraph(5))               #Plot a random graph
gplot(rgraph(5))               #Plot a random graph
gplot(rgraph(5))               #Plot a random graph
gplot(rgraph(5),usecurv=TRUE)  #This time, use curved edges
gplot(rgraph(5),mode="mds")    #Try an alternative layout scheme
#A colorful demonstration...
gplot(rgraph(5,diag=TRUE),diag=TRUE,vertex.cex=1:5,vertex.sides=3:8,
vertex.col=1:5,vertex.border=2:6,vertex.rot=(0:4)*72,
displaylabels=TRUE,label.bg="gray90")
x<-rgraph(20,4)
#Create a response structure
y<-x[1,,]+4*x[2,,]+2*x[3,,]
x
x
y
x
x[1, , ]
nl<-netlm(y,x,reps=100)
#Examine the results
summary(nl)
?rgraph
rgraph(1, 2)
rgraph(2, 2)
rgraph(3, 2)
rgraph(4, 2)
rgraph(20, 4)
x <- rgraph(4, 2)
dim(x)
x <- rgraph(20, 4)
dim(x)
s <- c(100, 100, 95, 95, 90, 90, rep(85, 6), rep(80, 3))
s
mean(s)
mean(s - 5)
mean(s - 8)
s - 8
s <- s - 8
s / 100
s <- s / 100
s
s * 40
s[1:6] <- c(95, 95, 90, 90, 85, 85)
s
s[1:6] <- c(95, 95, 90, 90, 85, 85)/100
s
s * 40
mean(s)
length(s)
s[7:15]
s[6]
s[7:15] - 2
s[7:15] - .02
s[7:15] <- s[7:15] - .02
s
mean(s)
s * 40
??"genetic algorithm"
phonetic(c('Euler','Gauss','Hilbert','Knuth','Lloyd','Lukasiewicz','Wachs'),method='soundex')
library(stringdist)
phonetic(c('Euler','Gauss','Hilbert','Knuth','Lloyd','Lukasiewicz','Wachs'),method='soundex')
"evolutionary"
??"evolutionary"
research <- read.table("Research.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
setwd("/Users/jasonbell/Desktop/Ideas/MI/blender")
cons <- read.table("concepts.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
trans <- read.table("transformations.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
apps <- read.table("apps.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
objects <- read.table("objects.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
boardgames <- read.table("boardgames.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
bathItems <- read.table("BathroomItems.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
Gobjects <- c(apps, objects)
busmods <- read.table("BusinessModels.txt", header = TRUE,
quote = "\"", stringsAsFactors = FALSE)[, 1]
gamebusmods <- read.table("GamingBusinessModels.txt", header = TRUE,
quote = "\"", stringsAsFactors = FALSE)[, 1]
abm <- c(busmods, gamebusmods)
research <- read.table("Research.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
setwd("/Users/jasonbell/Desktop/Ideas/MI/blender")
cons <- read.table("concepts.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
trans <- read.table("transformations.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
apps <- read.table("apps.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
objects <- read.table("objects.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
boardgames <- read.table("boardgames.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
bathItems <- read.table("BathroomItems.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
Gobjects <- c(apps, objects)
busmods <- read.table("BusinessModels.txt", header = TRUE,
quote = "\"", stringsAsFactors = FALSE)[, 1]
gamebusmods <- read.table("GamingBusinessModels.txt", header = TRUE,
quote = "\"", stringsAsFactors = FALSE)[, 1]
abm <- c(busmods, gamebusmods)
research <- read.table("Research.txt", header = TRUE, quote = "\"",
stringsAsFactors = FALSE)[, 1]
research
sample(research, size = 2)
research
rownames(research) <- as.numeric(rownames(research) + 0)
rownames(research)
names(research)
names(research) <- seq(1:length(research))
research
sample(research, size = 2)
